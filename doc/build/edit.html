<body class="focus-tail"><h1 operator="" id="editing">Editing</h1><h2 id="editing-primitives">Editing primitives</h2><p>Lisp programs are expected to use the following primitives to edit the Neomacs DOM. These primitives provides <a href="positions.html">Positions</a>-based interface and handles text-node splitting and merging automatically. These primitives also maintain <a href="undo.html">Undo</a> history, update renderer-side DOM,  manage setup and destruction of observers and computed attributes, and allocate <code>neomacs-identifier</code>'s.</p><dl><dt>Function: <code>delete-nodes</code> <code>(beg end)</code></dt><dd>Delete nodes between BEG and END and returns nil.</dd><dd>BEG and END must be sibling positions.  If END is nil, delete children
starting from BEG till the end of its parent.</dd><dt>Function: <code>extract-nodes</code> <code>(beg end)</code></dt><dd>Like <code>delete-nodes</code>, but clone and return the deleted contents.</dd><dt>Function: <code>insert-nodes</code> <code>(marker-or-pos &amp;rest things)</code></dt><dd>Insert THINGS at MARKER-OR-POS.</dd><dd>THINGS can be DOM nodes or strings, which are converted to text nodes.</dd><dt>Function: <code>move-nodes</code> <code>(beg end to)</code></dt><dd>Move nodes between BEG and END to TO and returns nil.</dd><dd>BEG and END must be sibling positions.  If END is nil, move children
starting from BEG till the end of its parent.</dd></dl><h2 id="compound-editing-operations">Compound editing operations</h2><p>Functions implemented using <a href="#editing-primitives">Editing primitives</a>, provided for convenience:</p><dl><dt>Function: <code>splice-node</code> <code>(node)</code></dt><dd>Splice children of NODE in place of NODE itself.</dd><dt>Function: <code>join-nodes</code> <code>(dst src)</code></dt><dd>Join DST and SRC nodes.</dd><dd>This moves all children of SRC into DST and deletes SRC.</dd><dt>Function: <code>raise-node</code> <code>(node)</code></dt><dd>Replace NODE's parent with NODE.</dd><dt>Function: <code>split-node</code> <code>(&amp;optional (pos (focus)))</code></dt><dd>Split node containing POS at POS.</dd><dd>Let parent be the node containing POS. This involves inserting a clone
of parent after parent, and moving children after POS into the clone.</dd><dt>Function: <code>wrap-node</code> <code>(node new-node)</code></dt><dd>Insert NEW-NODE around NODE.</dd><dd>NODE become the last child of NEW-NODE.</dd><dt>Function: <code>delete-node</code> <code>(node)</code></dt><dd>Delete a single NODE.</dd><dt>Function: <code>replace-node</code> <code>(node new-node)</code></dt><dd>Replace NODE with NEW-NODE.</dd></dl><h2 id="editing-commands">Editing commands</h2><p>The following generic editing commands are avaliable in any Neomacs buffer:</p><dl><dt>Function: <code>new-line</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Insert a new line node (br element) at MARKER.</dd><dt>Function: <code>backward-delete</code> <code>(&amp;optional (marker (focus)))</code></dt><dt>Function: <code>forward-delete</code> <code>(&amp;optional (marker (focus)))</code></dt><dt>Function: <code>backward-delete-word</code> <code>(&amp;optional (marker (focus)))</code></dt><dt>Function: <code>self-insert-command</code> <code>()</code></dt><dd>Insert the last typed character into current buffer.</dd></dl><p><code operator="">self-insert-command</code> can be extended:</p><dl><dt>Standard generic function: <code>self-insert-aux</code> <code>(buffer marker string)</code></dt><dt>Function: <code>self-insert-char</code> <code>()</code></dt><dd>Get the last typed character from <code>*this-command-keys*</code>.</dd><dd>Called by <code>self-insert-command</code> to get the character for insertion.</dd></dl></body>