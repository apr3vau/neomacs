<body class="focus-tail"><h1 class="" id="reactive-dom">Reactive DOM</h1><p class="">Neomacs maintain reactive DOMs based on <code>lwcells</code>. This enables observers and computed attributes to update in real-time depending on DOM content.</p><h2 class="" id="nodes">Nodes</h2><p class="">This section documents the low-level node classes making up Neomacs's reactive DOM. Note that the interface here is low-level in the sense that <code>text-node</code>'s are being exposed. The majority of Neomacs API hides <code>text-node</code>'s as an implementation detail and the DOM conceptually consists of <code>element</code>'s and <code>character</code>'s.</p><dl><dt>Class: <code>node</code></dt><dt>Class: <code>text-node</code></dt><dt>Class: <code>element</code></dt><dt>Function: <code>element-p</code> <code>(object)</code></dt><dt>Function: <code>text-node-p</code> <code>(object)</code></dt><dt>Function: <code>tag-name-p</code> <code>(node tag-name)</code></dt><dd>Test if NODE is an element with TAG-NAME.</dd><dt>Standard generic function: <code>clone-node</code> <code>(node &amp;optional deep)</code></dt><dd>Clone NODE.</dd><dd>If DEEP is non-nil, recursively clone all descendant.
DEEP defaults to T.</dd><dt>Function: <code>child-nodes</code> <code>(node)</code></dt><dd>Return immediate child nodes of NODE as a list.</dd><dt>Function: <code>children</code> <code>(node)</code></dt><dd>Return immediate child elements of NODE as a list.</dd><dt>Function: <code>text-content</code> <code>(node)</code></dt><dt>Function: <code>get-elements-by-class-name</code> <code>(node class)</code></dt><dd>Find all descendant elements of NODE with CLASS.</dd></dl><h2 class="" id="traversing-dom">Traversing DOM</h2><dl><dt>Function: <code>do-dom</code> <code>(function node)</code></dt><dd>Call FUNCTION on every descendant of NODE in post-order.
This includes <code>element</code>s and <code>text-node</code>s. Returns NODE.</dd><dt>Function: <code>do-elements</code> <code>(function node)</code></dt><dd>Like <code>do-dom</code>, but only call FUNCTION on <code>element</code>s. Returns NODE.</dd></dl><h2 id="attributes">Attributes</h2><p>In Neomacs, every attribute is backed by a cell, i.e. other cells can depend on attribute value, or attribute values themselves can be computed and updated from other cell value. The following functions get and set attribute values or function to compute them.</p><dl><dt>Function: <code>attribute</code> <code>(element name)</code></dt><dt>Function: <code>set-attribute-function</code> <code>(element attribute function)</code></dt><dd>Set a computed attribute.
Make ATTRIBUTE of ELEMENT computed by calling FUNCTION with
ELEMENT as a single argument.</dd></dl><p>Attributes can have any name. Those named by strings are kept in sync with renderer-side attributes with the same names, i.e. changes in Lisp side are pushed to renderer (but not the other way). Those with non-string names (typically symbols) instead has no counterpart on renderer side.</p><p>Attribute related utility functions:</p><dl><dt>Function: <code>add-class</code> <code>(element class)</code></dt><dd>Add CSS CLASS to ELEMENT.</dd><dt>Function: <code>remove-class</code> <code>(element class)</code></dt><dd>Remove CSS CLASS from ELEMENT.</dd><dt>Function: <code>class-p</code> <code>(node class &amp;rest more-classes)</code></dt><dd>Test if NODE is an element of one of CSS CLASS or MORE-CLASSES.</dd></dl><h2 id="low-level-dom-edits"><p>Low-level DOM edits</p></h2><p>This section documents low-level primitives for modifying Lisp-side DOM. They are used to implement programmer-facing editing operations, see <a href="edit.html#editing-primitives">Editing primitives</a>.</p><dl><dt>Function: <code>insert-before</code> <code>(parent new-node reference)</code></dt><dd>Insert NEW-NODE under PARENT before REFERENCE.</dd><dd>If REFERENCE is nil, insert NEW-NODE as last child of PARENT.
Returns NEW-NODE.</dd><dt>Function: <code>append-child</code> <code>(parent new-node)</code></dt><dd>Insert NEW-NODE as last child of PARENT.</dd><dd>Returns NEW-NODE.</dd><dt>Function: <code>append-children</code> <code>(parent children)</code></dt><dd>Insert CHILDREN as last children of PARENT.</dd><dd>Returns CHILDREN.</dd><dt>Function: <code>remove-node</code> <code>(node)</code></dt><dd>Remove NODE from DOM tree.</dd></dl><h2 id="notes-on-dom-consistency">Notes on DOM consistency</h2><p>It is imperative that Lisp-side and renderer-side DOM are consistent. Otherwise, editing operations may behave erroneously and inconsistency can be propagated and amplified. All belts are off  in such case (which can be recovered only by re-opening the buffer, or in some case <code>revert-buffer</code>).</p><p>Currently, the following consistency rules are enforced:</p><dl><li>Lisp-side and renderer-side DOM must have exactly the same structure, i.e. <code>element</code>'s and <code>text-node</code>'s must 1-1 correspond. Parent, child and sibling (order included) relations must be exactly the same.</li><li>Length of  corresponding text nodes must be exactly the same.</li><li>It is acceptable that corresponding elements have different tag-names.<p>For example, <code>render-focus</code> currently exploit this to change <code>br</code> element into <code>div</code> element when focused, to display visible highlight.</p></li><li>It is acceptable that corresponding text nodes have different characters at the same offset.</li><li>It is acceptable that corresponding elements have different attribute values for an attribute named by a string on Lisp-side, but keep in mind that changes from Lisp-side will be pushed to renderer and overwrite its values.</li><li>It is totally ok that renderer-side element has some attribute not known to Lisp-side. This is useful for internal bookkeeping done by JavaScript code which Lisp doesn't need to know. Lisp-side has similar ability by using attributes not named by strings.</li></dl>
</body>