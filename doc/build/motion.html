<body class="focus-tail"><h1 operator="" class="" id="motion">Motion</h1><h2 id="selectable-positions">Selectable positions</h2><p>Neomacs try to keep the focus at selectable positions after every command invocation.</p><dl><dt>Function: <code>selectable-p</code> <code>(pos)</code></dt><dd>Test if POS is selectable.</dd><dt>Standard generic function: <code>selectable-p-aux</code> <code>(buffer pos)</code></dt><dd>Extension point for <code>selectable-p</code>.</dd><dd>Test if POS is selectable in BUFFER.</dd></dl><h2 id="motion-by-nodes-and-elements">Motion by nodes and elements</h2><dl><dt>Function: <code>forward-node</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to closest selectable preorder successor.</dd><dt>Function: <code>backward-node</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to closest selectable preorder predecessor.</dd><dt>Function: <code>forward-node-cycle</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Like <code>forward-node</code>, but may wrap around to beginning of buffer.</dd><dt>Function: <code>backward-node-cycle</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Like <code>backward-node</code>, but may wrap around to beginning of buffer.</dd><dt>Function: <code>forward-element</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to first element (excluding line break) to the right.</dd><dt>Function: <code>backward-element</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to first element (excluding line break) to the left.</dd><dt>Function: <code>backward-up-node</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to closest selectable parent.</dd></dl><h2 id="top-level-motion">Top-level motion</h2><dl><dt>Function: <code>beginning-of-defun</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to current or previous toplevel node.</dd><dt>Function: <code>end-of-defun</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to next toplevel node.</dd><dt>Function: <code>beginning-of-buffer</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to beginning of buffer.</dd><dt>Function: <code>end-of-buffer</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to end of buffer.</dd></dl><h2 id="word-motion">Word motion</h2><dl><dt>Standard generic function, setf-able: <code>word-boundary-list</code> <code>(object)</code></dt><dt>Function: <code>word-character-p</code> <code>(buffer node)</code></dt><dd>Test if NODE is a word constituent character in BUFFER.</dd><dt>Function: <code>word-start-p</code> <code>(pos)</code></dt><dd>Test if POS is at start of a word.</dd><dt>Function: <code>word-end-p</code> <code>(pos)</code></dt><dd>Test if POS is at end of a word.</dd></dl><p>Word motion commands:</p><dl><dt>Function: <code>forward-word</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to next word end position.</dd><dt>Function: <code>backward-word</code> <code>(&amp;optional (marker (focus) non-interactive))</code></dt><dd>Move to previous word start position.</dd></dl><h2 id="line-motion">Line motion</h2><p>Test if position is at line boundary:</p><ul operator=""><dt>Function: <code>block-element-p</code> <code>(element)</code></dt><dd>Test if ELEMENT is a block element.</dd><dt>Standard generic function: <code>block-element-p-aux</code> <code>(buffer element)</code></dt><dd>Extension point for <code>block-element-p</code>.</dd><dd>Test if ELEMENT is a block element in BUFFER.</dd><dt>Function: <code>line-start-p</code> <code>(pos)</code></dt><dd>Test if POS is at start of a line.</dd><dt>Function: <code>line-end-p</code> <code>(pos)</code></dt><dd>Test if POS is at end of a line.</dd><p>Move to line boundary:</p><dl><dt>Function: <code>beginning-of-line</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Move to beginning of line.</dd><dd>Also returns number of skipped selectable position, useful for
non-interactive use.</dd><dt>Function: <code>end-of-line</code> <code>(&amp;optional (marker (focus) non-interactive))</code></dt><dd>Move to end of line.</dd></dl><p>The following commands try to keep horizontal location approximately the same. Currently, we do this by counting the number of selectable positions between current focus position and beginning-of-line position, and try to keep that number the same.</p><dl><dt>Function: <code>previous-line</code> <code>(&amp;optional (n 1) (marker (focus)))</code></dt><dd>Move to N-th previous line.</dd><dd>Try to keep horizontal location approximately the same.</dd><dt>Function: <code>next-line</code> <code>(&amp;optional (n 1) (marker (focus)))</code></dt><dd>Move to N-th next line.</dd><dd>Try to keep horizontal location approximately the same.</dd><dt>Standard generic function, setf-able: <code>scroll-lines</code> <code>(object)</code></dt><dt>Function: <code>scroll-up-command</code> <code>()</code></dt><dd>Move up <code>scroll-lines</code>.</dd><dt>Function: <code>scroll-down-command</code> <code>()</code></dt><dd>Move down <code>scroll-lines</code>.</dd></dl></ul></body>