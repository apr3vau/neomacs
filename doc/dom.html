<!DOCTYPE html>
<html><head></head><body><h1 class="" id="reactive-dom">Reactive DOM</h1><p class="">Neomacs maintain reactive DOMs based on <code>lwcells</code>. This enables observers and computed attributes to update in real-time depending on DOM content.</p><h2 class="" id="nodes">Nodes</h2><p class="">This section documents the low-level node classes making up Neomacs&#39;s reactive DOM. Note that the interface here is low-level in the sense that <code>text-node</code>&#39;s are being exposed. The majority of Neomacs API hides <code>text-node</code>&#39;s as an implementation detail and the DOM conceptually consists of <code>element</code>&#39;s and <code>character</code>&#39;s.</p><dl><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">classdoc</span><span class="symbol">&#39;node</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">classdoc</span><span class="symbol">&#39;text-node</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">classdoc</span><span class="symbol">&#39;element</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;element-p</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;text-node-p</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;tag-name-p</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;clone-node</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;child-nodes</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;children</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;text-content</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;get-elements-by-class-name</span></div></dt></dl><h2 class="" id="traversing-dom">Traversing DOM</h2><dl><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;do-dom</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;do-elements</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;next-node</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;previous-node</span></div></dt></dl><h2 id="attributes">Attributes</h2><p>In Neomacs, every attribute is backed by a cell. Other cells can depend on attribute value, and attribute values themselves can be computed and updated from other cell values. The following functions get and set attribute values or functions for compute them.</p><dl><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;attribute</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;set-attribute-function</span></div></dt></dl><p>Attributes can have any name. Those named by strings are kept in sync with renderer-side attributes with the same names, i.e. changes in Lisp side are pushed to renderer (but not the other way). Those with non-string names (typically symbols) instead have no counterpart on renderer side.</p><p>Attribute related utility functions:</p><dl><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;add-class</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;remove-class</span></div></dt><dt class="comma-expr"><div class="list"><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;class-p</span></div></dt></dl><h2 id="low-level-dom-edits"><p>Low-level DOM edits</p></h2><p>This section documents low-level primitives for modifying Lisp-side DOM. They are used to implement programmer-facing editing operations, see <a href="edit.html#editing-primitives">Editing primitives</a>.</p><dl><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;insert-before</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;append-child</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;append-children</span></div></dt><dt class="comma-expr" operator=""><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;remove-node</span></div></dt></dl><h2 id="notes-on-dom-consistency">Notes on DOM consistency</h2><p>It is imperative that Lisp-side and renderer-side DOM are consistent. Otherwise, editing operations may behave erroneously and inconsistency can be propagated and amplified. All belts are off in such case (which can be recovered only by re-opening the buffer, or in some cases <code>revert-buffer</code>). </p><p>Normally, all programmer-facing editing operations (<a href="edit.html#editing-primitives">Editing primitives</a>) maintain consistency, under the assumption that the requested editing operations only ever result in <i>valid</i> HTML. If attempts are made to create invalid HTML, the renderer will usually perform &quot;fix-up&quot;s to restore the DOM to valid HTML, but currently Neomacs has no way to know about these. Note that creating invalid HTML then fix them in <code>with-post-command</code> (<a href="edit.html#editing-hooks">Editing hooks</a>) is <i>not</i> acceptable. Examples of operations that might shoot you in the foot:</p><ul><li operator="">Creating a <code>&lt;p&gt;</code> element inside another <code>&lt;p&gt;</code> element.</li><li>Creating a <code>&lt;li&gt;</code> element without surrounding <code>&lt;ol&gt;</code> or <code>&lt;ul&gt;</code> element.</li></ul><p>If you are using <a href="#low-level-dom-edits">Low-level DOM edits</a>, or debugging implementation of editing primitives, take care to enforce the following consistency rules:</p><dl><li>Lisp-side and renderer-side DOM must have exactly the same structure, i.e. <code>element</code>&#39;s and <code>text-node</code>&#39;s must 1-1 correspond. Parent, child and sibling (order included) relations must be exactly the same.</li><li>Length of  corresponding text nodes must be exactly the same.</li><li>It is acceptable that corresponding elements have different tag-names.</li><li>It is acceptable that corresponding text nodes have different characters at the same offset.</li><li>It is acceptable that corresponding elements have different attribute values for an attribute named by a string on Lisp-side, but keep in mind that changes from Lisp-side will be pushed to renderer and overwrite its values.</li><li>It is totally ok that renderer-side elements have some attributes not known to Lisp-side. This is useful for internal bookkeeping done by JavaScript code which Lisp doesn&#39;t need to know. Lisp-side has similar ability by using attributes not named by strings.</li></dl>
</body></html>