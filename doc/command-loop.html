<!DOCTYPE html>
<html><head></head><body><h1 operator="" id="command-loop">Command Loop</h1><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;start-command-loop</span></div></dt></dl><h2 id="command-dispatch">Command dispatch</h2><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">&#39;*this-command*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">&#39;*this-command-keys*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">&#39;*last-command*</span></div></dt></dl><h2 id="buffer-transactions">Buffer transactions</h2><p>Neomacs commands are processed in a transactional manner, following  the 2PL (2-phase locking) model. During a command invocation, every <code>with-current-buffer</code> form obtains a lock for the buffer. All buffer locks are released at the end of command invocation. <code>on-pre-command</code> is run when the buffer lock is obtained for the first time and <code>on-post-command</code> is run when the buffer lock is released. When <code>with-current-buffer</code> runs outside any command invocation, it effectively starts a new command invocation for running its body and will run <code>on-pre-command</code> and <code>on-post-command</code> like normal command invocations. It&#39;s important to note the interaction between <code>with-current-buffer</code> and transactions.</p><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;with-current-buffer</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;on-pre-command</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;on-post-command</span></div></dt></dl><h2 id="condition-handling">Condition handling</h2><p>Normally, Neomacs command loop handles any error conditions that reach it. It runs approriate hook, logs a message, then continue processing the next command.</p><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">&#39;*quit-hook*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">&#39;*error-hook*</span></div></dt></dl><p>It is also possible to ask the command loop to invoke the debugger instead of handling error conditions.</p><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">&#39;*debug-on-error*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;toggle-debug-on-error</span></div></dt></dl><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">classdoc</span><span class="symbol">&#39;user-error</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;user-error</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;with-demoted-errors</span></div></dt></dl><h2 id="defining-commands">Defining commands</h2><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">&#39;define-command</span></div></dt></dl></body></html>