<h1 operator="">Command Loop</h1><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'start-command-loop</span></div></dt></dl><h2>Command dispatch</h2><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">'*this-command*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">'*this-command-keys*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">'*last-command*</span></div></dt></dl><h2>Buffer transactions</h2><p>Neomacs commands are processed in a transactional manner, following  the 2PL (2-phase locking) model. During a command invocation, every <code>with-current-buffer</code> form obtains a lock for the buffer. All buffer locks are released at the end of command invocation. <code>on-pre-command</code> is run when the buffer lock is obtained for the first time and <code>on-post-command</code> is run when the buffer lock is released. When <code>with-current-buffer</code> runs outside any command invocation, it effectively starts a new command invocation for running its body and will run <code>on-pre-command</code> and <code>on-post-command</code> like normal command invocations. It's important to note the interaction between <code>with-current-buffer</code> and transactions.</p><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'with-current-buffer</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'on-pre-command</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'on-post-command</span></div></dt></dl><h2>Condition handling</h2><p>Normally, Neomacs command loop handles any error conditions that reach it. It runs approriate hook, logs a message, then continue processing the next command.</p><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">'*quit-hook*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">'*error-hook*</span></div></dt></dl><p>It is also possible to ask the command loop to invoke the debugger instead of handling error conditions.</p><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">vardoc</span><span class="symbol">'*debug-on-error*</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'toggle-debug-on-error</span></div></dt></dl><dl><dt operator="" class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">classdoc</span><span class="symbol">'user-error</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'user-error</span></div></dt><dt class=" comma-expr"><div class="list" operator=""><span class="symbol" operator="">fundoc</span><span class="symbol">'with-demoted-errors</span></div></dt></dl>